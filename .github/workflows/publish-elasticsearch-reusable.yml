name: Publish to Elasticsearch (Reusable)

on:
  workflow_call:

jobs:
  find-changed-artifacts:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
      has-changes: ${{ steps.set-matrix.outputs.has-changes }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 2
      
      - name: Identify changed metadata files
        id: set-matrix
        run: |
          # Get changed metadata files from last commit only
          CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD | grep '_metadata.json$' || true)
          
          # Filter out latest/ directory - only index versioned artifacts
          CHANGED_FILES=$(echo "$CHANGED_FILES" | grep -v '/latest/' || true)
          
          if [ -z "$CHANGED_FILES" ]; then
            echo "No changed versioned metadata files found"
            echo "has-changes=false" >> $GITHUB_OUTPUT
            echo "matrix={\"include\":[]}" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "Changed metadata files (excluding latest/):"
          echo "$CHANGED_FILES"
          
          # Build JSON array for matrix
          MATRIX_JSON=$(echo "$CHANGED_FILES" | jq -R -s -c 'split("\n") | map(select(length > 0)) | map({"file": .})')
          echo "matrix={\"include\":$MATRIX_JSON}" >> $GITHUB_OUTPUT
          echo "has-changes=true" >> $GITHUB_OUTPUT

  publish-artifact:
    needs: find-changed-artifacts
    if: needs.find-changed-artifacts.outputs.has-changes == 'true'
    runs-on: ubuntu-latest
    strategy:
      matrix: ${{ fromJson(needs.find-changed-artifacts.outputs.matrix) }}
      fail-fast: false
      max-parallel: 5
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: main
      
      - name: Load metadata
        id: load-metadata
        run: |
          if [ ! -f "${{ matrix.file }}" ]; then
            echo "Error: Metadata file ${{ matrix.file }} not found"
            exit 1
          fi
          
          # Extract metadata fields
          NAME=$(jq -r '.Name // ""' "${{ matrix.file }}")
          DESCRIPTION=$(jq -r '.Description // ""' "${{ matrix.file }}")
          IDENTIFIER=$(jq -r '.Identifier // ""' "${{ matrix.file }}")
          
          echo "name=$NAME" >> $GITHUB_OUTPUT
          echo "description=$DESCRIPTION" >> $GITHUB_OUTPUT
          echo "identifier=$IDENTIFIER" >> $GITHUB_OUTPUT
          
          # Parse file path: username/artifact_type/slugified_name/v{version}/..._metadata.json
          if [[ "${{ matrix.file }}" =~ ^([^/]+)/([^/]+)/([^/]+)/v([0-9]+)/ ]]; then
            echo "github_username=${BASH_REMATCH[1]}" >> $GITHUB_OUTPUT
            echo "artifact_type=${BASH_REMATCH[2]}" >> $GITHUB_OUTPUT
            echo "slugified_name=${BASH_REMATCH[3]}" >> $GITHUB_OUTPUT
            echo "version=${BASH_REMATCH[4]}" >> $GITHUB_OUTPUT
            echo "github_path=${BASH_REMATCH[1]}/${BASH_REMATCH[2]}/${BASH_REMATCH[3]}/v${BASH_REMATCH[4]}" >> $GITHUB_OUTPUT
          else
            echo "Warning: Could not parse file path for ${{ matrix.file }}"
          fi
      
      - name: Generate name embedding
        id: name-embedding
        if: steps.load-metadata.outputs.name != ''
        env:
          EMBEDDINGS_URL: ${{ secrets.EMBEDDINGS_URL }}
        run: |
          RESPONSE=$(curl -s -X POST "$EMBEDDINGS_URL" \
            -H "Content-Type: application/json" \
            -d "{\"inputs\":[\"${{ steps.load-metadata.outputs.name }}\"]}"
          )
          echo "$RESPONSE" > /tmp/name_embedding.json
          echo "embedding=$RESPONSE" >> $GITHUB_OUTPUT
      
      - name: Generate description embedding
        id: desc-embedding
        if: steps.load-metadata.outputs.description != ''
        env:
          EMBEDDINGS_URL: ${{ secrets.EMBEDDINGS_URL }}
        run: |
          # Escape description for JSON
          DESC=$(echo '${{ steps.load-metadata.outputs.description }}' | jq -R -s .)
          RESPONSE=$(curl -s -X POST "$EMBEDDINGS_URL" \
            -H "Content-Type: application/json" \
            -d "{\"inputs\":[$DESC]}"
          )
          echo "$RESPONSE" > /tmp/desc_embedding.json
          echo "embedding=$RESPONSE" >> $GITHUB_OUTPUT
      
      - name: Index to Elasticsearch
        env:
          ES_URL: ${{ secrets.ES_URL }}
        run: |
          # Load original metadata
          METADATA=$(cat "${{ matrix.file }}")
          
          # Add embeddings to metadata from temp files
          # The embeddings API returns an array of embeddings, we need the first one
          if [ -f /tmp/name_embedding.json ] && [ -f /tmp/desc_embedding.json ]; then
            UPDATED_METADATA=$(echo "$METADATA" | jq \
              --slurpfile name_emb /tmp/name_embedding.json \
              --slurpfile desc_emb /tmp/desc_embedding.json \
              '. + {"Name_embedding": $name_emb[0][0], "Description_embedding": $desc_emb[0][0]}')
          elif [ -f /tmp/name_embedding.json ]; then
            UPDATED_METADATA=$(echo "$METADATA" | jq \
              --slurpfile name_emb /tmp/name_embedding.json \
              '. + {"Name_embedding": $name_emb[0][0]}')
          elif [ -f /tmp/desc_embedding.json ]; then
            UPDATED_METADATA=$(echo "$METADATA" | jq \
              --slurpfile desc_emb /tmp/desc_embedding.json \
              '. + {"Description_embedding": $desc_emb[0][0]}')
          else
            UPDATED_METADATA="$METADATA"
          fi
          
          # Debug: Show what we're sending to ES
          echo "Indexing to Elasticsearch:"
          echo "$UPDATED_METADATA" | jq -C '.' || echo "$UPDATED_METADATA"
          
          # Index to Elasticsearch
          ES_ENDPOINT="${ES_URL%/}/artifacts/_doc"
          curl -X POST "$ES_ENDPOINT" \
            -H "Content-Type: application/json" \
            -d "$UPDATED_METADATA" \
            --fail-with-body
          
          echo "Successfully indexed ${{ matrix.file }} to Elasticsearch"
      
      # Note: Per-artifact Marketplace API callback removed.
      # Artifacts are now staged upfront when publish request is created,
      # and moved to registry via the /finalize endpoint after PR merge.
